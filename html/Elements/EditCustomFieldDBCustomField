<div class="rt-extension-dbcustomfield-search" id="<%$htmlid%>">
<!-- this is what the user sees as dropdown field, the real input is hidden -->
<input name="rt-extension-dbcustomfield-search-input" style="width: 400px; table-layout: fixed;">
<input name="<%$fieldName%>" type="hidden" value="">
</div>
<%INIT>
	$idcount++;
	my $htmlid="rt-extension-dbcustomfield-$idcount";

	unless ($CustomField->isDBCustomField()) {
		$m->out('No DB customfield!');
		return;
	}

	my ($name, $c) = RT::Extension::DBCustomField->new()->getConfigByCustomField($CustomField);

	my $fieldName = '';
	if ($Name) {
		$fieldName = $Name;
	} else {
		$fieldName = $NamePrefix. $CustomField->Id. '-Values';
	}

	my $ticket = undef;
	if (ref($Object) eq 'RT::Ticket') {
		$ticket = $Object;
	}

	my $selectedData = undef;

	if ($Values && $Values->Count()) {
		my $value = $Values->Next()->Content;
		$selectedData = RT::Extension::DBCustomField->new()->getReturnValue($name, $value, $ticket);
	}

	# Prepare configuration for JS
	my $json = encode_json({
		sourceName => $name,
		fieldName => $fieldName,
		value => $selectedData,
		id => $htmlid,
		fieldTpl => $c->{field_tpl} || undef,
		fieldConfig => $c->{field_config} || {},
		returnFieldTpl => $c->{returnfield_tpl} || undef,
		returnFieldConfig => $c->{returnfield_config} || {},
		objectType => $ticket ? ref($ticket) : '',
		objectId => $ticket ? $ticket->Id : ''
	});

	my $fieldTpl = $c->{field_tpl} || undef;

	$fieldTpl =~ s/\n//g;
	$fieldTpl =~ s/\r//g;
	$fieldTpl =~ s/^\s+|\s+$//g;

	my $fieldID = $c->{field_id};
</%INIT>

<script type="text/javascript">

	var $ = jQuery; // RT doesn't do that for us.

	//TODO: Pass template variables as configuration hash.
	$( function() {
		//var config = $.parseJSON('<% $json | n %>');

		$( "input[name=rt-extension-dbcustomfield-search-input]" ).autocomplete({
			delay: 500,
			minLength: 2,
			open: function() {
				if ($(this).is(':not(:focus)')) {
					$(this).autocomplete('close');
				}
			},
			source: function (request, response){
				//console.log($(this));

				var dataURL = "<% RT->Config->Get('WebURL') %>" + "RT-Extension-DBCustomField/Provider.html?source="
				    + "<%$name%>" + "&query=" + $("input[name=rt-extension-dbcustomfield-search-input]").val();

				//TODO: Remove
				console.log("Requesting data from URL: " + dataURL);

				$.ajax({
					type: "POST",
					url: dataURL,
					contentType: "application/json; charset=utf-8",
					dataType: "json", // let JQuery automatically convert the response to JSON.
					success: function (data, text) {
						// Provider.html puts
						// - result[] with hashes inside
						// - { "globalid", "id", "name", "net_global_id_c", "shortname", "shortname_c" } which are defined in the configuration as 'returnfields' and 'returnfield_id'
						// TODO: Remove
						console.log("success: " + text);
						console.log(data);

						// Return formatted data
						var formattedResponse = [];

						$.each(data.result, function (i, a, k) {
							formattedResponse.push(a); // Use the entire map, formatting is below.
						});

						response(formattedResponse.slice(0, 10)); // Limit result set
					},
					error: function (request, status, error) {
						// TODO: Remove
						console.log("error: " + request.responseText);
					}
				})

			},
			select: function(event, ui) {
				// TODO: Remove
				console.log( "Selected: " + ui.item.name + " aka " + ui.item.globalid );

				// 'name' is what the user sees in the input field which we defined ourselves in $this.
				//TODO: Use the small template?
				$(this).val(ui.item.name);

				// 'fieldName' is our hidden input form and the global stored ID for the CF. This can be defined in the configuration.
				$("input[name='<%$fieldName%>']").val(ui.item["<%$fieldID%>"]);

				// tell autocomplete that the select event has set a value
				return false;
			},
			close: function(event, ui) {
				return true;
			}
		})
		.data("ui-autocomplete")._renderItem = function (ul, item) {
			// Overwrite received data with our own template
			var tmpl = "<%$fieldTpl%>"; //TODO: Figure out how to avoid HTML escaping here.

			// required by extractValue helper
			this.item = item;
			var parent = this;

			function extractValue(match, string, offset) {
				console.log("Match: '" + match + "' offset: '" + offset + "' string: '" + string + "'");
				console.log(parent.item);
				console.log("Item Value: " + parent.item[string]);

				return parent.item[string];
			}

			var formattedTmpl = tmpl.replace(/\{([^\}]+)\}/g, extractValue)

			console.log("Template: '" + tmpl + "' formatted: '" + formattedTmpl + "'");

			return $("<li></li>")
			.data("ui-autocomplete-item", item)
			.append(formattedTmpl)
			.appendTo(ul);
		}; // .data("ui-autocomplete")

	}); // function
</script>

<%ARGS>
$Object => undef
$CustomField => undef
$NamePrefix => ''
$Default => undef
$Values => undef
$MaxValues => undef
$Name => undef
$Cols
$Rows
</%ARGS>
<%once>
	use Data::Dumper;
	use JSON::XS;
	my $idcount = 0;
</%once>
