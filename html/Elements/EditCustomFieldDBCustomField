<div class="rt-extension-dbcustomfield-search" id="<%$htmlid%>">
<!-- this is what the user sees as dropdown field, the real input is hidden -->
<input name="rt-extension-dbcustomfield-search-input" style="width: 400px; table-layout: fixed;">
<input name="<%$fieldName%>" type="hidden" value="">
</div>
<%INIT>
	$idcount++;
	my $htmlid="rt-extension-dbcustomfield-$idcount";

	unless ($CustomField->isDBCustomField()) {
		$m->out('No DB customfield!');
		return;
	}

	my ($name, $c) = RT::Extension::DBCustomField->new()->getConfigByCustomField($CustomField);

	my $fieldName = '';
	if ($Name) {
		$fieldName = $Name;
	} else {
		$fieldName = $NamePrefix. $CustomField->Id. '-Values';
	}

	my $ticket = undef;
	if (ref($Object) eq 'RT::Ticket') {
		$ticket = $Object;
	}

	my $selectedData = undef;

	if ($Values && $Values->Count()) {
		my $value = $Values->Next()->Content;
		$selectedData = RT::Extension::DBCustomField->new()->getReturnValue($name, $value, $ticket);
	}

	my $fieldTpl = $c->{field_tpl} || undef;
	$fieldTpl =~ s/\n//g;
	$fieldTpl =~ s/\r//g;
	$fieldTpl =~ s/^\s+|\s+$//g;
	$fieldTpl =~ s/"/&quot;/g;
	my $returnFieldTpl = $c->{returnfield_tpl} || undef;
	$returnFieldTpl =~ s/\n//g;
	$returnFieldTpl =~ s/\r//g;
	$returnFieldTpl =~ s/^\s+|\s+$//g;
	$returnFieldTpl =~ s/"/&quot;/g;
	my $returnFieldSmallTpl = $c->{returnfield_small_tpl} || undef;
	$returnFieldSmallTpl =~ s/\n//g;
	$returnFieldSmallTpl =~ s/\r//g;
	$returnFieldSmallTpl =~ s/^\s+|\s+$//g;
	$returnFieldSmallTpl =~ s/"/&quot;/g;

	# Prepare configuration for JS
	my $json = encode_json({
		webURL => RT->Config->Get('WebURL'),
		resultLimit => 10,
		sourceName => $name,
		fieldName => $fieldName,
		value => $selectedData,
		id => $htmlid,
		fieldTpl => $fieldTpl,
		returnFieldTpl => $returnFieldTpl,
		returnFieldSmallTpl => $returnFieldSmallTpl,
		objectType => $ticket ? ref($ticket) : '',
		objectId => $ticket ? $ticket->Id : ''
	});

</%INIT>

<script type="text/javascript">

	var $ = jQuery; // RT doesn't do that for us.

	$( function() {
		var config = $.parseJSON('<% $json | n %>');

		$( "input[name=rt-extension-dbcustomfield-search-input]" ).autocomplete({
			delay: 500,
			minLength: 2,
			open: function() {
				if ($(this).is(':not(:focus)')) {
					$(this).autocomplete('close');
				}
			},
			source: function (request, response){
				//console.log($(this));

				var dataURL = config['webURL'] + "RT-Extension-DBCustomField/Provider.html?source="
				    + config['sourceName'] + "&query=" + $("input[name=rt-extension-dbcustomfield-search-input]").val();

				//TODO: Remove
				console.debug("Requesting data from URL: " + dataURL);

				$.ajax({
					type: "POST",
					url: dataURL,
					contentType: "application/json; charset=utf-8",
					dataType: "json", // let JQuery automatically convert the response to JSON.
					success: function (data, text) {
						// Provider.html puts
						// - result[] with hashes inside
						// - { "field_value", "id", "name", "net_global_id_c", "shortname", "shortname_c" } which are defined in the configuration as 'returnfields'
						// TODO: Remove
						//console.log("success: " + text);
						//console.log(data);

						// Return formatted data
						var formattedResponse = [];

						$.each(data.result, function (i, a, k) {
							formattedResponse.push(a);
						});

						response(formattedResponse);
					},
					error: function (request, status, error) {
						// TODO: Remove
						//console.log("error: " + request.responseText);
					}
				})

			},
			select: function(event, ui) {
				// TODO: Remove
				//console.debug( "Selected: " + ui.item.name + " aka " + ui.item.field_value );

				var tmpl = config['returnFieldTpl']; //This is put into the form on select.

				// required by extractValue helper
				this.item = ui.item;
				var parent = this;

				function extractValue(match, string, offset) {
					//console.log("Match: '" + match + "' offset: '" + offset + "' string: '" + string + "'");
					//console.log(parent.item);
					//console.log("Item Value: " + parent.item[string]);

					return parent.item[string];
				}

				var formattedTmpl = tmpl.replace(/\{([^\}]+)\}/g, extractValue)

				//console.log("Template: '" + tmpl + "' formatted: '" + formattedTmpl + "'");

				// 'name' is what the user sees in the input field which we defined ourselves in $this.
				$(this).val(formattedTmpl);

				// 'fieldName' is our hidden input form and the global stored ID for the CF. This can be defined in the configuration.
				$("input[name='" + config['fieldName'] + "']").val(ui.item["field_value"]);

				// tell autocomplete that the select event has set a value
				return false;
			},
			close: function(event, ui) {
				return true;
			}
		})
		.data("ui-autocomplete")._renderItem = function (ul, item) {
			// Overwrite received data with our own template
			var tmpl = config['fieldTpl']; //This is rendered in the search dropdown.

			// required by extractValue helper
			this.item = item;
			var parent = this;

			function extractValue(match, string, offset) {
				//console.log("Match: '" + match + "' offset: '" + offset + "' string: '" + string + "'");
				//console.log(parent.item);
				//console.log("Item Value: " + parent.item[string]);

				return parent.item[string];
			}

			var formattedTmpl = tmpl.replace(/\{([^\}]+)\}/g, extractValue)

			console.log("Template: '" + tmpl + "' formatted: '" + formattedTmpl + "'");

			return $("<li></li>")
			.data("ui-autocomplete-item", item)
			.append(formattedTmpl)
			.appendTo(ul);
		}; // .data("ui-autocomplete")

	}); // function
</script>

<%ARGS>
$Object => undef
$CustomField => undef
$NamePrefix => ''
$Default => undef
$Values => undef
$MaxValues => undef
$Name => undef
$Cols
$Rows
</%ARGS>
<%once>
	use Data::Dumper;
	use JSON::XS;
	my $idcount = 0;
</%once>
